var colorCode = class { constructor(...e) { return "string" == typeof arguments[0] ? this.hex(...e) : this.set(...e) } set(e, t, r, s) { return this.red = void 0 !== e ? e : 0, this.green = void 0 !== t ? t : 0, this.blue = void 0 !== r ? r : 0, this.alpha = void 0 !== s ? s : void 0, this } hex(e) { return void 0 !== e ? this.parseHex(e) : this.getHex() } rgb(e) { return void 0 !== e ? this.parseRgb(e) : this.getRgb() } hsl() { return getHsl() } hslDeltaTo(e) { var t = this.rgbToHsl(this.red, this.green, this.blue), r = e.rgbToHsl(e.red, e.green, e.blue), s = []; return s[0] = parseInt(r[0]) - parseInt(t[0]) + "deg", s[1] = (parseInt(r[1]) - parseInt(t[1])) / parseInt(t[1]) * 100 + "%", s[2] = (parseInt(r[2]) - parseInt(t[2])) / parseInt(t[2]) * 100 + "%", s } parseHex(e) { if (6 == (e = e.replace("#", "")).length || 8 == e.length) { var t = this.splitString(e, 2); this.red = this.hexToNumber(t[0]), this.green = this.hexToNumber(t[1]), this.blue = this.hexToNumber(t[2]), this.alpha = void 0 !== t[3] ? this.hexToOpacity(t[3]) : void 0 } else { if (3 != e.length && 4 != e.length) throw "Invalid HEX string provided to parseHex()! Provided: " + e; t = this.splitString(e, 1); this.red = this.hexToNumber(t[0] + t[0]), this.green = this.hexToNumber(t[1] + t[1]), this.blue = this.hexToNumber(t[2] + t[2]), this.alpha = void 0 !== t[3] ? this.hexToOpacity(t[3]) : void 0 } return this } parseRgb(e) { e.indexOf("(") > -1 && (e = e.substring(e.lastIndexOf("(") + 1, e.lastIndexOf(")"))); var t = (e = e.replace(/\s+/g, "")).split(","); if (3 != t.length && 4 != t.length) throw "Invalid RGB string provided to parseRgb()"; return this.red = parseInt(t[0]), this.green = parseInt(t[1]), this.blue = parseInt(t[2]), t[3] = parseFloat(t[3]), isNaN(t[3]) ? this.alpha = void 0 : this.alpha = this.round(t[3], 2), this } getHex() { var e = "", t = [this.red, this.green, this.blue], r = !0; return t.forEach(t => { e += this.numberToHex(t), this.isDoubleChar(this.numberToHex(t)) || (r = !1) }), void 0 !== this.alpha && (r = !1, e += this.decToHexAlpha(this.alpha)), r && (e = this.dedupe(e)), e = "#" + e } getRgb() { var e = void 0 !== this.alpha ? "rgba(" : "rgb("; return e += [this.red, this.green, this.blue].join(","), e += void 0 !== this.alpha ? "," + this.alpha + ")" : ")" } getHsl() { var e = this.rgbToHsl(this.red, this.green, this.blue), t = void 0 !== this.alpha ? "hsla(" : "hsl("; return t += e.join(","), t += void 0 !== this.alpha ? "," + this.alpha + ")" : ")" } numberToHex(e) { var t = e.toString(16); return 1 == t.length ? "0" + t : t } decToHexAlpha(e) { return this.numberToHex(this.round(100 * e * 2.55, 0)) } testHexAlpha() { for (var e = 100; e > 0; e -= 1)console.log(e + "% - " + this.decToHexAlpha(e / 100)) } hexToOpacity(e) { var t = Math.pow(16, e.length) - 1; return this.round(this.hexToNumber(e) / t, 2) } hexToNumber(e) { return parseInt(e, 16) } round(e, t) { return Number(Math.round(e + "e" + t) + "e-" + t) } splitString(e, t) { return e.match(new RegExp(".{1," + t + "}", "g")) } isDoubleChar(e) { return e[0] == e[1] } dedupe(e) { for (var t = e.split(""), r = 1; r < t.length; r += 2)t[r] = ""; return t.join("") } rgbToHsl(e, t, r) { e /= 255, t /= 255, r /= 255; var s, h, i = Math.max(e, t, r), a = Math.min(e, t, r), n = (i + a) / 2; if (i == a) s = h = 0; else { var o = i - a; switch (h = n > .5 ? o / (2 - i - a) : o / (i + a), i) { case e: s = (t - r) / o + (t < r ? 6 : 0); break; case t: s = (r - e) / o + 2; break; case r: s = (e - t) / o + 4 }s /= 6 } return [100 * s / 100 * 360 + .5 | 0, (100 * h + .5 | 0) + "%", (100 * n + .5 | 0) + "%"] } hslToRgb(e, t, r) { var s, h, i; if (0 == t) s = h = i = r; else { function a(e, t, r) { return r < 0 && (r += 1), r > 1 && (r -= 1), r < 1 / 6 ? e + 6 * (t - e) * r : r < .5 ? t : r < 2 / 3 ? e + (t - e) * (2 / 3 - r) * 6 : e } var n = r < .5 ? r * (1 + t) : r + t - r * t, o = 2 * r - n; s = a(o, n, e + 1 / 3), h = a(o, n, e), i = a(o, n, e - 1 / 3) } return [255 * s, 255 * h, 255 * i] } };