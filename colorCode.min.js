class colorCode {
    constructor(...args) { return this.set(...args); }
    set(red, green, blue, alpha) { this.red = (red !== undefined) ? red : 0; this.green = (green !== undefined) ? green : 0; this.blue = (blue !== undefined) ? blue : 0; this.alpha = (alpha !== undefined) ? alpha : undefined; return this; }
    hex(hex) { if (hex !== undefined) { return this.parseHex(hex); } else { return this.getHex(); } }
    rgb(rgb) { if (rgb !== undefined) { return this.parseRgb(rgb); } else { return this.getRgb(); } }
    hsl() { return getHsl(); }
    hslDelta(object) { var a = this.rgbToHsl(this.red, this.green, this.blue); var b = object.rgbToHsl(object.red, object.green, object.blue); var diff = []; diff[0] = (parseInt(b[0]) - parseInt(a[0])) / parseInt(a[0]) * 100 + '%'; diff[1] = (parseInt(b[1]) - parseInt(a[1])) / parseInt(a[1]) * 100 + '%'; diff[2] = (parseInt(b[2]) - parseInt(a[2])) / parseInt(a[2]) * 100 + '%'; return diff; }
    parseHex(hex) {
        hex = hex.replace('#', ''); if (hex.length == 6 || hex.length == 8) { var channels = this.splitString(hex, 2); this.red = this.hexToNumber(channels[0]); this.green = this.hexToNumber(channels[1]); this.blue = this.hexToNumber(channels[2]); this.alpha = (channels[3] !== undefined) ? this.hexToOpacity(channels[3]) : undefined; } else if (hex.length == 3 || hex.length == 4) { var channels = this.splitString(hex, 1); this.red = this.hexToNumber(channels[0] + channels[0]); this.green = this.hexToNumber(channels[1] + channels[1]); this.blue = this.hexToNumber(channels[2] + channels[2]); this.alpha = (channels[3] !== undefined) ? this.hexToOpacity(channels[3]) : undefined; } else { throw "Invalid HEX string provided to parseHex()! Provided: " + hex; }
        return this;
    }
    parseRgb(rgb) {
        if (rgb.indexOf('(') > -1) { rgb = rgb.substring(rgb.lastIndexOf("(") + 1, rgb.lastIndexOf(")")); }
        rgb = rgb.replace(/\s+/g, ''); var channels = rgb.split(','); if (channels.length == 3 || channels.length == 4) { this.red = parseInt(channels[0]); this.green = parseInt(channels[1]); this.blue = parseInt(channels[2]); channels[3] = parseFloat(channels[3]); if (!isNaN(channels[3])) { this.alpha = this.round(channels[3], 2); } else { this.alpha = undefined; } } else { throw "Invalid RGB string provided to parseRgb()"; }
        return this;
    }
    getHex() {
        var output = ''; var colorChannels = [this.red, this.green, this.blue]; var dedupeFlag = true; colorChannels.forEach(value => { output += this.numberToHex(value); if (!this.isDoubleChar(this.numberToHex(value))) { dedupeFlag = false; } }); if (this.alpha !== undefined) { dedupeFlag = false; output += this.decToHexAlpha(this.alpha); }
        if (dedupeFlag) { output = this.dedupe(output); }
        output = '#' + output; return output;
    }
    getRgb() { var output = (this.alpha !== undefined) ? 'rgba(' : 'rgb('; output += [this.red, this.green, this.blue].join(','); output += (this.alpha !== undefined) ? ',' + this.alpha + ')' : ')'; return output; }
    getHsl() { var hsl = this.rgbToHsl(this.red, this.green, this.blue); var output = (this.alpha !== undefined) ? 'hsla(' : 'hsl('; output += hsl.join(','); output += (this.alpha !== undefined) ? ',' + this.alpha + ')' : ')'; return output; }
    numberToHex(number) { var hex = number.toString(16); if (hex.length == 1) { return "0" + hex; } else { return hex; } }
    decToHexAlpha(decimal) { return this.numberToHex(this.round(decimal * 100 * (255 / 100), 0)); }
    testHexAlpha() { for (var i = 100; i > 0; i -= 1) { console.log(i + "% - " + this.decToHexAlpha(i / 100)); } }
    hexToOpacity(hex) { var scale = Math.pow(16, hex.length) - 1; return this.round(this.hexToNumber(hex) / scale, 2); }
    hexToNumber(hex) { return parseInt(hex, 16); }
    round(value, precision) { return Number(Math.round(value + 'e' + precision) + 'e-' + precision); }
    splitString(string, size) { return string.match(new RegExp('.{1,' + size + '}', 'g')); }
    isDoubleChar(string) { return string[0] == string[1]; }
    dedupe(string) {
        var chars = string.split(''); for (var i = 1; i < chars.length; i += 2) { chars[i] = ''; }
        return chars.join('');
    }
    rgbToHsl(r, g, b) {
    r /= 255, g /= 255, b /= 255; var max = Math.max(r, g, b), min = Math.min(r, g, b); var h, s, l = (max + min) / 2; if (max == min) { h = s = 0; } else {
        var d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min); switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; }
        h /= 6;
    }
        return [(h * 100 + 0.5) | 0, ((s * 100 + 0.5) | 0) + '%', ((l * 100 + 0.5) | 0) + '%'];
    }
    hslToRgb(h, s, l) {
        var r, g, b; if (s == 0) { r = g = b = l; } else {
            function hue2rgb(p, q, t) { if (t < 0) t += 1; if (t > 1) t -= 1; if (t < 1 / 6) return p + (q - p) * 6 * t; if (t < 1 / 2) return q; if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6; return p; }
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s; var p = 2 * l - q; r = hue2rgb(p, q, h + 1 / 3); g = hue2rgb(p, q, h); b = hue2rgb(p, q, h - 1 / 3);
        }
        return [r * 255, g * 255, b * 255];
    }
}